import { jsx as i, Fragment as u, jsxs as Y } from "react/jsx-runtime";
import { createContext as $, useState as m, useContext as z, useRef as B, useEffect as l, createElement as b, memo as g, useMemo as N } from "react";
import { createPortal as Z } from "react-dom";
const G = $(null), tt = ({ children: e }) => {
  const [t, n] = m({
    setEditor: (o) => {
      n((s) => ({ ...s, editor: o }));
    }
  });
  return /* @__PURE__ */ i(G.Provider, { value: t, children: e });
}, v = () => {
  const e = z(G);
  if (!e)
    throw new Error("useEditorInstance must be used within EditorInstanceProvider");
  return e;
}, gt = () => {
  const { editor: e } = v();
  if (!e)
    throw new Error(
      "useEditor used before the load of the editor instance. You can wrap your component in `<WithEditor>` or make use of `useEditorMaybe` hook and ensure the `editor` exists."
    );
  return e;
}, et = () => v().editor, J = $(null), ot = ({ children: e }) => {
  const [t, n] = m(() => ({
    setRefCanvas(o) {
      n((s) => ({ ...s, refCanvas: o }));
    },
    setCustomModal(o) {
      n((s) => ({ ...s, customModal: o }));
    },
    setCustomAssets(o) {
      n((s) => ({ ...s, customAssets: o }));
    },
    setCustomBlocks(o) {
      n((s) => ({ ...s, customBlocks: o }));
    },
    setCustomRte(o) {
      n((s) => ({ ...s, customRte: o }));
    },
    setCustomStyles(o) {
      n((s) => ({ ...s, customStyles: o }));
    },
    setCustomLayers(o) {
      n((s) => ({ ...s, customLayers: o }));
    },
    setCustomSelectors(o) {
      n((s) => ({ ...s, customSelectors: o }));
    },
    setCustomTraits(o) {
      n((s) => ({ ...s, customTraits: o }));
    },
    setReady(o) {
      n((s) => ({ ...s, ready: o }));
    }
  }));
  return /* @__PURE__ */ i(J.Provider, { value: t, children: e });
}, y = () => {
  const e = z(J);
  if (!e)
    throw new Error("useEditorOptions must be used within EditorOptionsProvider");
  return e;
};
function st(...e) {
  return (Array.isArray(e[0]) ? e[0] : [...e]).filter(Boolean).join(" ");
}
function P(e) {
  return typeof e == "function";
}
function C() {
}
const K = (e) => typeof e == "string", nt = async (e) => {
  const t = document.createElement("link");
  t.href = e, t.rel = "stylesheet", document.head.appendChild(t);
}, Q = (e) => {
  const t = K(e) ? { id: e, src: e } : e;
  return new Promise((n, o) => {
    const s = document.createElement("script");
    if (document.querySelector(`script[src="${t.src}"]`))
      return n(t.id);
    s.src = t.src, s.onload = () => n(t.id), s.onerror = () => o(t.id), document.head.appendChild(s);
  });
}, rt = (e) => {
  const t = e.map((n) => Q(n));
  return Promise.allSettled(t);
}, q = (e) => function() {
  const n = B(null);
  return l(() => {
    const { current: o } = n;
    o && (K(e) ? o.innerHTML = e : o.appendChild(e));
  }, [n.current]), /* @__PURE__ */ i("div", { ref: n });
}, H = /* @__PURE__ */ new WeakMap();
function O(e) {
  if (!e)
    return () => /* @__PURE__ */ i(u, {});
  const t = H.get(e);
  if (t)
    return t;
  const n = function({ children: s }) {
    return Z(b("div", null, s), e);
  };
  return H.set(e, n), n;
}
const vt = g(function({ children: e }) {
  const { editor: t } = v(), n = y(), [o, s] = m(!1), [c, r] = m({
    assets: [],
    types: [],
    close: () => {
    },
    select: () => {
    },
    Container: () => /* @__PURE__ */ i(u, {})
  });
  return l(() => {
    if (!t)
      return;
    const a = t.Assets.events.custom, d = ({ open: p, assets: E, types: M, select: h, close: f, container: w }) => {
      p && r({
        assets: E,
        types: M,
        select: h,
        close: f,
        Container: O(w)
      }), s(p);
    };
    return t.on(a, d), () => {
      t.off(a, d);
    };
  }, [t]), l(() => n.setCustomAssets(!0), []), t ? P(e) ? e({ open: o, ...c }) : /* @__PURE__ */ i(u, {}) : /* @__PURE__ */ i(u, {});
}), St = g(function({ children: e }) {
  const { editor: t } = v(), n = y(), [o, s] = m(() => ({
    blocks: [],
    dragStart: C,
    dragStop: C,
    mapCategoryBlocks: /* @__PURE__ */ new Map(),
    Container: () => /* @__PURE__ */ i(u, {})
  }));
  return l(() => {
    if (!t)
      return;
    const c = t.Blocks.events.custom, r = ({ blocks: a, container: d, dragStart: p, dragStop: E }) => {
      const M = a.reduce((h, f) => {
        const w = f.getCategoryLabel(), k = h.get(w);
        return k ? k.push(f) : h.set(w, [f]), h;
      }, /* @__PURE__ */ new Map());
      s({
        blocks: a,
        dragStart: p,
        dragStop: E,
        mapCategoryBlocks: M,
        Container: O(d)
      });
    };
    return t.on(c, r), t.Blocks.__trgCustom(), () => {
      t.off(c, r);
    };
  }, [t]), l(() => n.setCustomBlocks(!0), []), t ? P(e) ? e(o) : /* @__PURE__ */ i(u, {}) : /* @__PURE__ */ i(u, {});
});
function Ct({ children: e, ...t }) {
  const n = y(), o = B(null);
  return l(() => {
    o.current && n.setRefCanvas(o.current);
  }, [o.current]), /* @__PURE__ */ i("div", { ...t, ref: o, children: e });
}
const yt = g(function({ children: e }) {
  const { editor: t } = v(), [n, o] = m(() => ({
    devices: [],
    selected: "",
    select: C
  }));
  return l(() => {
    if (!t)
      return;
    const { Devices: s } = t, c = s.events.all, r = () => {
      var a;
      o({
        devices: s.getDevices(),
        selected: (a = s.getSelected()) == null ? void 0 : a.id,
        select: (d) => s.select(d)
      });
    };
    return t.on(c, r), r(), () => {
      t.off(c, r);
    };
  }, [t]), t ? P(e) ? e(n) : /* @__PURE__ */ i(u, {}) : /* @__PURE__ */ i(u, {});
}), ct = (e) => !!(e && !Array.isArray(e) && typeof e == "object");
async function it(e) {
  const t = e.map(({ id: r, src: a }) => ({ id: r, src: a })), n = e.reduce(
    (r, a) => (r[a.id] = a, r),
    {}
  ), o = [], s = [];
  return (await rt(t)).forEach((r) => {
    r.status === "fulfilled" ? o.push(n[r.value]) : s.push(n[r.reason]);
  }), { loaded: o, failed: s };
}
const at = async (e) => {
  const t = [...e], n = {};
  if (t.length) {
    const o = {}, s = [];
    if (t.forEach((c, r) => {
      ct(c) && (o[c.id] = { index: r }, s.push(c));
    }), s.length) {
      const { loaded: c } = await it(s);
      c.forEach(({ id: r, options: a }) => {
        o[r].loaded = !0, n[r] = a || {};
      });
    }
    Object.keys(o).forEach((c) => {
      const r = o[c];
      r.loaded ? t[r.index] = c : t[r.index] = !1;
    });
  }
  return {
    plugins: t.filter(Boolean),
    pluginOptions: n
  };
}, ut = g(function({
  children: e,
  className: t,
  style: n,
  options: o = {},
  plugins: s = [],
  grapesjs: c,
  grapesjsCss: r,
  onEditor: a = C,
  onReady: d,
  onUpdate: p,
  waitReady: E,
  ...M
}) {
  const { setEditor: h } = v(), f = y(), [w, k] = m(!1), L = B(null);
  l(() => {
    if (!f.ready || !L.current)
      return;
    const V = L.current, R = f.refCanvas;
    let S, j = {}, D = [];
    const F = (x) => {
      const X = {
        height: "100%",
        ...o,
        plugins: [...D, ...o.plugins || []],
        pluginsOpts: {
          ...o.pluginsOpts,
          ...j
        },
        modal: {
          custom: !!f.customModal,
          ...o.modal
        },
        assetManager: {
          custom: !!f.customAssets,
          ...o.assetManager
        },
        styleManager: {
          custom: !!f.customStyles,
          ...o.styleManager
        },
        blockManager: {
          custom: !!f.customBlocks,
          ...o.blockManager
        },
        richTextEditor: {
          custom: !!f.customRte,
          ...o.richTextEditor
        },
        layerManager: {
          custom: !!f.customLayers,
          ...o.layerManager
        },
        traitManager: {
          custom: !!f.customTraits,
          ...o.traitManager
        },
        selectorManager: {
          custom: !!f.customSelectors,
          ...o.selectorManager
        },
        container: R || V,
        customUI: !!R,
        // Disables all default panels if Canvas is used
        ...R ? {
          panels: { defaults: [] }
        } : {}
      };
      S = x.init(X), h(S), a(S), p && S.on("update", () => {
        p(S.getProjectData(), S);
      }), S.onReady(() => {
        k(!0), d == null || d(S);
      });
    };
    return (async () => {
      r && await nt(r);
      const x = await at(s);
      D = x.plugins, j = x.pluginOptions, typeof c == "string" ? (await Q(c), F(window.grapesjs)) : F(c);
    })(), () => S == null ? void 0 : S.destroy();
  }, [f.ready]);
  const A = o.height ?? "100%", I = o.width ?? "100%", W = st("gjs-editor-wrapper", t), _ = E && !w, T = N(
    () => ({
      ...n,
      height: A,
      width: I
    }),
    [A, I, n]
  ), U = N(
    () => ({
      ...T,
      ..._ ? {
        opacity: 0,
        width: 0,
        height: 0
      } : {}
    }),
    [T, _]
  );
  return /* @__PURE__ */ Y(u, { children: [
    E && !w ? /* @__PURE__ */ i("div", { className: W, style: T, children: E }) : null,
    /* @__PURE__ */ i("div", { ...M, ref: L, className: W, style: U, children: e })
  ] });
}), dt = g(function() {
  const e = y();
  return l(() => e.setReady(!0), []), /* @__PURE__ */ i(u, {});
}), Et = g(function({ children: t, ...n }) {
  return /* @__PURE__ */ i(tt, { children: /* @__PURE__ */ i(ot, { children: /* @__PURE__ */ Y(ut, { ...n, children: [
    t,
    /* @__PURE__ */ i(dt, {})
  ] }) }) });
}), ht = g(function({ children: e }) {
  const { editor: t } = v(), n = y(), [o, s] = m(() => ({
    root: void 0,
    Container: () => /* @__PURE__ */ i(u, {})
  }));
  return l(() => {
    if (!t)
      return;
    const { Layers: c } = t, r = c.events.custom, a = ({ container: d }) => {
      s({
        root: c.getRoot(),
        Container: O(d)
      });
    };
    return t.on(r, a), c.__trgCustom({}), () => {
      t.off(r, a);
    };
  }, [t]), l(() => n.setCustomLayers(!0), []), t ? P(e) ? e(o) : /* @__PURE__ */ i(u, {}) : /* @__PURE__ */ i(u, {});
}), Pt = g(function({ children: e }) {
  const { editor: t } = v(), n = y(), [o, s] = m(!1), [c, r] = m({
    title: /* @__PURE__ */ i(u, {}),
    content: /* @__PURE__ */ i(u, {}),
    attributes: {},
    close: C
  });
  return l(() => {
    if (!t)
      return;
    const a = "modal", d = ({ open: p, title: E, content: M, close: h, attributes: f }) => {
      p && r({
        title: b(q(E)),
        content: b(q(M)),
        attributes: f,
        close: h
      }), s(p);
    };
    return t.on(a, d), () => {
      t.off(a, d);
    };
  }, [t]), l(() => n.setCustomModal(!0), []), t ? typeof e == "function" ? e({ open: o, ...c }) : /* @__PURE__ */ i(u, {}) : /* @__PURE__ */ i(u, {});
}), Mt = g(function({ children: e }) {
  const { editor: t } = v(), [n, o] = m(() => ({
    pages: [],
    selected: void 0,
    select: C,
    add: C,
    remove: C
  }));
  return l(() => {
    if (!t)
      return;
    const { Pages: s } = t, c = s.events.all, r = () => {
      o({
        pages: s.getAll(),
        selected: s.getSelected(),
        select: (...a) => s.select(...a),
        add: (...a) => s.add(...a),
        remove: (...a) => s.remove(...a)
      });
    };
    return t.on(c, r), r(), () => {
      t.off(c, r);
    };
  }, [t]), t ? P(e) ? e(n) : /* @__PURE__ */ i(u, {}) : /* @__PURE__ */ i(u, {});
}), wt = g(function({ children: e }) {
  const { editor: t } = v(), n = y(), [o, s] = m(() => ({
    selectors: [],
    states: [],
    selectedState: "",
    targets: [],
    addSelector: C,
    removeSelector: C,
    setState: C,
    Container: () => /* @__PURE__ */ i(u, {})
  }));
  return l(() => {
    if (!t)
      return;
    const { Selectors: c } = t, r = c.events.custom, a = ({ container: d }) => {
      s({
        selectors: c.getSelected(),
        states: c.getStates(),
        selectedState: c.getState(),
        targets: c.getSelectedTargets().map((p) => p.getSelectorsString()),
        addSelector: (...p) => c.addSelected(...p),
        removeSelector: (...p) => c.removeSelected(...p),
        setState: (...p) => c.setState(...p),
        Container: O(d)
      });
    };
    return t.on(r, a), () => {
      t.off(r, a);
    };
  }, [t]), l(() => n.setCustomSelectors(!0), []), t ? P(e) ? e(o) : /* @__PURE__ */ i(u, {}) : /* @__PURE__ */ i(u, {});
}), Ot = g(function({ children: e }) {
  const { editor: t } = v(), n = y(), [o, s] = m(() => ({
    sectors: [],
    Container: () => /* @__PURE__ */ i(u, {})
  }));
  return l(() => {
    if (!t)
      return;
    const { Styles: c } = t, r = c.events.custom, a = ({ container: d }) => {
      s({
        sectors: c.getSectors({ visible: !0 }),
        Container: O(d)
      });
    };
    return t.on(r, a), () => {
      t.off(r, a);
    };
  }, [t]), l(() => n.setCustomStyles(!0), []), t ? P(e) ? e(o) : /* @__PURE__ */ i(u, {}) : /* @__PURE__ */ i(u, {});
}), kt = g(function({ children: e }) {
  const { editor: t } = v(), n = y(), [o, s] = m(() => ({
    traits: [],
    Container: () => /* @__PURE__ */ i(u, {})
  }));
  return l(() => {
    if (!t)
      return;
    const { Traits: c } = t, r = c.events.custom, a = ({ container: d }) => {
      s({
        traits: c.getCurrent(),
        Container: O(d)
      });
    };
    return t.on(r, a), c.__trgCustom(), () => {
      t.off(r, a);
    };
  }, [t]), l(() => n.setCustomTraits(!0), []), t ? P(e) ? e(o) : /* @__PURE__ */ i(u, {}) : /* @__PURE__ */ i(u, {});
}), xt = ({ children: e }) => et() ? /* @__PURE__ */ i(u, { children: e }) : /* @__PURE__ */ i(u, {});
export {
  vt as AssetsProvider,
  St as BlocksProvider,
  Ct as Canvas,
  yt as DevicesProvider,
  Et as Editor,
  ht as LayersProvider,
  Pt as ModalProvider,
  Mt as PagesProvider,
  wt as SelectorsProvider,
  Ot as StylesProvider,
  kt as TraitsProvider,
  xt as WithEditor,
  Et as default,
  gt as useEditor,
  et as useEditorMaybe
};
